"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.styles = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf3 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _react = _interopRequireDefault(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _classnames = _interopRequireDefault(require("classnames"));

var _keycode = _interopRequireDefault(require("keycode"));

var _warning = _interopRequireDefault(require("warning"));

var _utils = require("@material-ui/utils");

var _styles = require("@material-ui/core/styles");

var _Zoom = _interopRequireDefault(require("@material-ui/core/Zoom"));

var _transitions = require("@material-ui/core/styles/transitions");

var _Fab = _interopRequireDefault(require("@material-ui/core/Fab"));

var _reactHelpers = require("@material-ui/core/utils/reactHelpers");

var utils = _interopRequireWildcard(require("./utils"));

var _clamp = _interopRequireDefault(require("../utils/clamp"));

var dialRadius = 32;
var spacingActions = 16;
var styles = {
  /* Styles applied to the root element. */
  root: {
    zIndex: 1050,
    display: 'flex',
    pointerEvents: 'none'
  },

  /* Styles applied to the Button component. */
  fab: {
    pointerEvents: 'auto'
  },

  /* Styles applied to the root and action container elements when direction="up" */
  directionUp: {
    flexDirection: 'column-reverse'
  },

  /* Styles applied to the root and action container elements when direction="down" */
  directionDown: {
    flexDirection: 'column'
  },

  /* Styles applied to the root and action container elements when direction="left" */
  directionLeft: {
    flexDirection: 'row-reverse'
  },

  /* Styles applied to the root and action container elements when direction="right" */
  directionRight: {
    flexDirection: 'row'
  },

  /* Styles applied to the actions (`children` wrapper) element. */
  actions: {
    display: 'flex',
    pointerEvents: 'auto',
    '&$directionUp': {
      marginBottom: -dialRadius,
      paddingBottom: spacingActions + dialRadius
    },
    '&$directionRight': {
      marginLeft: -dialRadius,
      paddingLeft: spacingActions + dialRadius
    },
    '&$directionDown': {
      marginTop: -dialRadius,
      paddingTop: spacingActions + dialRadius
    },
    '&$directionLeft': {
      marginRight: -dialRadius,
      paddingRight: spacingActions + dialRadius
    }
  },

  /* Styles applied to the actions (`children` wrapper) element if `open={false}`. */
  actionsClosed: {
    transition: 'top 0s linear 0.2s',
    pointerEvents: 'none'
  }
};
exports.styles = styles;

var SpeedDial =
/*#__PURE__*/
function (_React$Component) {
  (0, _inherits2.default)(SpeedDial, _React$Component);

  function SpeedDial() {
    var _getPrototypeOf2;

    var _this;

    (0, _classCallCheck2.default)(this, SpeedDial);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, _getPrototypeOf3.default)(SpeedDial)).call.apply(_getPrototypeOf2, [this].concat(args)));
    _this.actions = [];
    _this.state = SpeedDial.initialNavigationState;

    _this.handleKeyboardNavigation = function (event) {
      var key = (0, _keycode.default)(event);
      var _this$props = _this.props,
          direction = _this$props.direction,
          onKeyDown = _this$props.onKeyDown;
      var _this$state = _this.state,
          focusedAction = _this$state.focusedAction,
          _this$state$nextItemA = _this$state.nextItemArrowKey,
          nextItemArrowKey = _this$state$nextItemA === void 0 ? key : _this$state$nextItemA;

      if (key === 'esc') {
        _this.closeActions(event, key);
      } else if (utils.sameOrientation(key, direction)) {
        event.preventDefault();
        var actionStep = key === nextItemArrowKey ? 1 : -1; // stay within array indices

        var nextAction = (0, _clamp.default)(focusedAction + actionStep, 0, _this.actions.length - 1);
        var nextActionRef = _this.actions[nextAction];
        nextActionRef.focus();

        _this.setState({
          focusedAction: nextAction,
          nextItemArrowKey: nextItemArrowKey
        });
      }

      if (onKeyDown) {
        onKeyDown(event, key);
      }
    };

    return _this;
  }

  (0, _createClass2.default)(SpeedDial, [{
    key: "createHandleSpeedDialActionButtonRef",

    /**
     * creates a ref callback for the Button in a SpeedDialAction
     * Is called before the original ref callback for Button that was set in buttonProps
     *
     * @param dialActionIndex {number}
     * @param origButtonRef {React.RefObject?}
     */
    value: function createHandleSpeedDialActionButtonRef(dialActionIndex, origButtonRef) {
      var _this2 = this;

      return function (ref) {
        _this2.actions[dialActionIndex + 1] = ref;

        if (origButtonRef) {
          origButtonRef(ref);
        }
      };
    }
  }, {
    key: "closeActions",
    value: function closeActions(event, key) {
      var onClose = this.props.onClose;
      this.actions[0].focus();
      this.setState(SpeedDial.initialNavigationState);

      if (onClose) {
        onClose(event, key);
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this3 = this,
          _actionsPlacementClas;

      var _this$props2 = this.props,
          ariaLabel = _this$props2.ariaLabel,
          _this$props2$ButtonPr = _this$props2.ButtonProps;
      _this$props2$ButtonPr = _this$props2$ButtonPr === void 0 ? {} : _this$props2$ButtonPr;
      var origDialButtonRef = _this$props2$ButtonPr.buttonRef,
          ButtonProps = (0, _objectWithoutProperties2.default)(_this$props2$ButtonPr, ["buttonRef"]),
          childrenProp = _this$props2.children,
          classes = _this$props2.classes,
          classNameProp = _this$props2.className,
          hidden = _this$props2.hidden,
          iconProp = _this$props2.icon,
          onClick = _this$props2.onClick,
          onClose = _this$props2.onClose,
          onKeyDown = _this$props2.onKeyDown,
          open = _this$props2.open,
          direction = _this$props2.direction,
          openIcon = _this$props2.openIcon,
          TransitionComponent = _this$props2.TransitionComponent,
          transitionDuration = _this$props2.transitionDuration,
          TransitionProps = _this$props2.TransitionProps,
          other = (0, _objectWithoutProperties2.default)(_this$props2, ["ariaLabel", "ButtonProps", "children", "classes", "className", "hidden", "icon", "onClick", "onClose", "onKeyDown", "open", "direction", "openIcon", "TransitionComponent", "transitionDuration", "TransitionProps"]); // Filter the label for valid id characters.

      var id = ariaLabel.replace(/^[^a-z]+|[^\w:.-]+/gi, '');
      var orientation = utils.getOrientation(direction);
      var totalValidChildren = 0;

      _react.default.Children.forEach(childrenProp, function (child) {
        if (_react.default.isValidElement(child)) totalValidChildren += 1;
      });

      this.actions = [];
      var validChildCount = 0;

      var children = _react.default.Children.map(childrenProp, function (child) {
        if (!_react.default.isValidElement(child)) {
          return null;
        }

        process.env.NODE_ENV !== "production" ? (0, _warning.default)(child.type !== _react.default.Fragment, ["Material-UI: the SpeedDial component doesn't accept a Fragment as a child.", 'Consider providing an array instead.'].join('\n')) : void 0;
        var delay = 30 * (open ? validChildCount : totalValidChildren - validChildCount);
        validChildCount += 1;
        var _child$props$ButtonPr = child.props.ButtonProps;
        _child$props$ButtonPr = _child$props$ButtonPr === void 0 ? {} : _child$props$ButtonPr;
        var origButtonRef = _child$props$ButtonPr.buttonRef,
            ChildButtonProps = (0, _objectWithoutProperties2.default)(_child$props$ButtonPr, ["buttonRef"]);
        var NewChildButtonProps = (0, _extends2.default)({}, ChildButtonProps, {
          buttonRef: _this3.createHandleSpeedDialActionButtonRef(validChildCount - 1, origButtonRef)
        });
        return _react.default.cloneElement(child, {
          ButtonProps: NewChildButtonProps,
          delay: delay,
          onKeyDown: _this3.handleKeyboardNavigation,
          open: open,
          id: "".concat(id, "-item-").concat(validChildCount)
        });
      });

      var icon = function icon() {
        if (_react.default.isValidElement(iconProp) && (0, _reactHelpers.isMuiElement)(iconProp, ['SpeedDialIcon'])) {
          return _react.default.cloneElement(iconProp, {
            open: open
          });
        }

        return iconProp;
      };

      var actionsPlacementClass = (_actionsPlacementClas = {}, (0, _defineProperty2.default)(_actionsPlacementClas, classes.directionUp, direction === 'up'), (0, _defineProperty2.default)(_actionsPlacementClas, classes.directionDown, direction === 'down'), (0, _defineProperty2.default)(_actionsPlacementClas, classes.directionLeft, direction === 'left'), (0, _defineProperty2.default)(_actionsPlacementClas, classes.directionRight, direction === 'right'), _actionsPlacementClas);
      var clickProp = {
        onClick: onClick
      };

      if (typeof document !== 'undefined' && 'ontouchstart' in document.documentElement) {
        clickProp = {
          onTouchEnd: onClick
        };
      }

      return _react.default.createElement("div", (0, _extends2.default)({
        className: (0, _classnames.default)(classes.root, actionsPlacementClass, classNameProp)
      }, other), _react.default.createElement(TransitionComponent, (0, _extends2.default)({
        in: !hidden,
        timeout: transitionDuration,
        unmountOnExit: true
      }, TransitionProps), _react.default.createElement(_Fab.default, (0, _extends2.default)({
        color: "primary",
        onKeyDown: this.handleKeyboardNavigation,
        "aria-label": ariaLabel,
        "aria-haspopup": "true",
        "aria-expanded": open ? 'true' : 'false',
        "aria-controls": "".concat(id, "-actions"),
        className: classes.fab
      }, clickProp, ButtonProps, {
        buttonRef: function buttonRef(ref) {
          _this3.actions[0] = ref;
          (0, _reactHelpers.setRef)(origDialButtonRef, ref);
        }
      }), icon())), _react.default.createElement("div", {
        id: "".concat(id, "-actions"),
        role: "menu",
        "aria-orientation": orientation,
        className: (0, _classnames.default)(classes.actions, (0, _defineProperty2.default)({}, classes.actionsClosed, !open), actionsPlacementClass)
      }, children));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, state) {
      // actions were closed while navigation state was not reset
      if (!props.open && state.nextItemArrowKey !== undefined) {
        return SpeedDial.initialNavigationState;
      }

      return null;
    }
    /**
     * refs to the Button that have an action associated to them in this SpeedDial
     * [Fab, ...(SpeedDialActions > Button)]
     * @type {HTMLButtonElement[]}
     */

  }]);
  return SpeedDial;
}(_react.default.Component);

SpeedDial.initialNavigationState = {
  /**
   * an index in this.actions
   */
  focusedAction: 0,

  /**
   * pressing this key while the focus is on a child SpeedDialAction focuses
   * the next SpeedDialAction.
   * It is equal to the first arrow key pressed while focus is on the SpeedDial
   * that is not orthogonal to the direction.
   * @type {utils.ArrowKey?}
   */
  nextItemArrowKey: undefined
};
process.env.NODE_ENV !== "production" ? SpeedDial.propTypes = {
  /**
   * The aria-label of the `Button` element.
   * Also used to provide the `id` for the `SpeedDial` element and its children.
   */
  ariaLabel: _propTypes.default.string.isRequired,

  /**
   * Properties applied to the [`Button`](/api/button/) element.
   */
  ButtonProps: _propTypes.default.object,

  /**
   * SpeedDialActions to display when the SpeedDial is `open`.
   */
  children: _propTypes.default.node.isRequired,

  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css-api) below for more details.
   */
  classes: _propTypes.default.object.isRequired,

  /**
   * @ignore
   */
  className: _propTypes.default.string,

  /**
   * The direction the actions open relative to the floating action button.
   */
  direction: _propTypes.default.oneOf(['up', 'down', 'left', 'right']),

  /**
   * If `true`, the SpeedDial will be hidden.
   */
  hidden: _propTypes.default.bool,

  /**
   * The icon to display in the SpeedDial Floating Action Button. The `SpeedDialIcon` component
   * provides a default Icon with animation.
   */
  icon: _propTypes.default.element.isRequired,

  /**
   * @ignore
   */
  onClick: _propTypes.default.func,

  /**
   * Callback fired when the component requests to be closed.
   *
   * @param {object} event The event source of the callback
   * @param {string} key The key pressed
   */
  onClose: _propTypes.default.func,

  /**
   * @ignore
   */
  onKeyDown: _propTypes.default.func,

  /**
   * If `true`, the SpeedDial is open.
   */
  open: _propTypes.default.bool.isRequired,

  /**
   * The icon to display in the SpeedDial Floating Action Button when the SpeedDial is open.
   */
  openIcon: _propTypes.default.node,

  /**
   * The component used for the transition.
   */
  TransitionComponent: _utils.componentPropType,

  /**
   * The duration for the transition, in milliseconds.
   * You may specify a single timeout for all transitions, or individually with an object.
   */
  transitionDuration: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.shape({
    enter: _propTypes.default.number,
    exit: _propTypes.default.number
  })]),

  /**
   * Properties applied to the `Transition` element.
   */
  TransitionProps: _propTypes.default.object
} : void 0;
SpeedDial.defaultProps = {
  hidden: false,
  direction: 'up',
  TransitionComponent: _Zoom.default,
  transitionDuration: {
    enter: _transitions.duration.enteringScreen,
    exit: _transitions.duration.leavingScreen
  }
};

var _default = (0, _styles.withStyles)(styles, {
  name: 'MuiSpeedDial'
})(SpeedDial);

exports.default = _default;