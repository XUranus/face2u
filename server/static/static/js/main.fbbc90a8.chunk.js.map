{"version":3,"sources":["logo.svg","ChartsSection.js","CameraSection.js","Main.js","App.js","Demo.js","serviceWorker.js","index.js"],"names":["module","exports","__webpack_require__","p","ChartsSection","data","this","props","console","log","option","xAxis","type","yAxis","series","react_default","a","createElement","lib_default","Component","MEDIA_WIDTH","MEDIA_HEIGHT","styles","card","minWidth","bullet","display","margin","transform","title","fontSize","pos","marginBottom","overlay","width","height","position","video","z-index","CameraSection","state","capturedImage","forwardTimes","setRef","webcam","_this2","capture","_callee","imageSrc","_this","input","detections","detectionsForSize","canvas","detection","image","regenerator_default","wrap","_context","prev","next","getScreenshot","setState","Object","assertThisInitialized","document","getElementById","faceapi","sent","withScore","length","alert","Image","src","onload","context","getContext","sourceX","relativeBox","x","sourceY","y","sourceWidth","sourceHeight","drawImage","splited","getImageData","axios","method","url","crossDomain","msg","matrix","then","res","updateEcharts","catch","error","stop","getElementsByTagName","setAttribute","ssdMobilenetv1","load","onPlay","timeInMs","concat","slice","reduce","total","t","dimensions","results","_ref3","HTMLVideoElement","resizedDetections","_ref","resizeCanvasAndResults","withBoxes","arguments","undefined","resizedResults","map","det","faceLandmarks","landmarks","lineWidth","drawLines","color","videoEl","currentTime","paused","ended","setTimeout","_this3","withFaceLandmarks","options","inputSize","scoreThreshold","ts","Date","now","faceDetectionTask","updateTimeStats","drawLandmarks","drawDetections","classes","Card_default","className","id","CardContent_default","Typography_default","gutterBottom","react_webcam_default","audio","ref","screenshotFormat","videoConstraints","facingMode","Button_default","variant","button","onClick","alt","withStyles","Main","echartsData","src_CameraSection","bind","src_ChartsSection","App","style","src_Main","Boolean","window","location","hostname","match","ReactDOM","render","src_App_0","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.fbbc90a8.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";","import React, { Component } from 'react'\nimport ReactEcharts from 'echarts-for-react';\n\nclass ChartsSection extends Component {\n\n    render() {\n        var data = this.props.data[0]\n        console.log('new echart render',data)\n        var option =  option = {\n            xAxis: {\n                type: 'category',\n                data: [\"愤怒\", \"恶心\", \"恐惧\",\"快乐\",\"悲伤\",\"惊讶\",\"自然\"]\n            },\n            yAxis: {\n                type: 'value'\n            },\n            series: [{\n                data: data,\n                type: 'bar'\n            }]\n        };\n\n        console.log(option)\n        return (\n            <ReactEcharts option={option} />\n        )\n    }\n}\n\nexport default ChartsSection;\n","import React, { Component } from 'react';\nimport Webcam from 'react-webcam'\nimport PropTypes, { func } from 'prop-types';\nimport { withStyles } from '@material-ui/core/styles';\nimport Card from '@material-ui/core/Card';\nimport CardActions from '@material-ui/core/CardActions';\nimport CardContent from '@material-ui/core/CardContent';\nimport Button from '@material-ui/core/Button';\nimport Typography from '@material-ui/core/Typography';\n//import opencv from 'opencv'\nimport axios from 'axios'\nimport ImageReader from './ImageReader'\nimport * as faceapi from 'face-api.js'\nimport { recognizeFaceExpressions } from 'face-api.js';\n//import * as canvas from 'canvas'\nimport ChartsSection from './ChartsSection'\n\nconst MEDIA_WIDTH = 640\nconst MEDIA_HEIGHT = 480\n\nconst styles = {\n    card: {\n      minWidth: 275,\n    },\n    bullet: {\n      display: 'inline-block',\n      margin: '0 2px',\n      transform: 'scale(0.8)',\n    },\n    title: {\n      fontSize: 14,\n    },\n    pos: {\n      marginBottom: 12,\n    },\n    overlay:{\n        width:MEDIA_WIDTH,\n        height:MEDIA_HEIGHT,\n        position: 'absolute'\n    },\n    video:{\n        'z-index': -1\n    }\n};\n\nfunction resizeCanvasAndResults(dimensions, canvas, results) {\n    const { width, height } = dimensions instanceof HTMLVideoElement\n        ? faceapi.getMediaDimensions(dimensions)\n        : dimensions\n    canvas.width = width\n    canvas.height = height\n\n    // resize detections (and landmarks) in case displayed image is smaller than\n    // original size\n    return faceapi.resizeResults(results, { width, height })\n}\n\nclass CameraSection extends Component {\n    state = {\n        capturedImage:'',\n        forwardTimes:[]\n    }\n    //https://www.npmjs.com/package/react-webcam \n    \n    setRef = webcam => {\n        this.webcam = webcam;\n    };\n\n    async recognizeFace() {\n        let input = document.getElementById('snapshot')\n        const canvas = document.getElementById('overlay')\n        canvas.width = input.width\n        canvas.height = input.height\n\n        const detections = await faceapi\n            .detectAllFaces(input)\n            //.withFaceLandmarks()\n        console.log(detections)\n        const detectionsForSize = faceapi\n            .resizeResults(detections, { width: input.width, height: input.height })\n        console.log(detectionsForSize)\n        // draw them into a canvas\n        //faceapi.drawLandmarks\n        faceapi.drawDetection(canvas, detectionsForSize, { withScore: true })\n    }\n\n    async componentDidMount() {\n        //init camera video id\n        let video = document.getElementsByTagName('video')[0]\n        video.setAttribute(\"id\",\"webcam\")\n        //load models\n        await faceapi.nets.ssdMobilenetv1.load('/models')\n        await faceapi.loadTinyFaceDetectorModel('/models')\n        //await faceapi.loadMtcnnModel('/models')\n        //await faceapi.loadFaceLandmarkModel('/models')\n        //await faceapi.loadFaceLandmarkTinyModel('/models')\n        //await faceapi.loadFaceRecognitionModel('/models')\n        //await faceapi.loadFaceExpressionModel('/models')\n        console.log('models load succ')\n        //init web camera\n        await this.onPlay(video)\n        console.log('camera video inited')\n    }\n\n\n    updateTimeStats(timeInMs) {\n        let forwardTimes = this.state.forwardTimes\n        forwardTimes = [timeInMs].concat(forwardTimes).slice(0, 30)\n        const avgTimeInMs = forwardTimes.reduce((total, t) => total + t) / forwardTimes.length\n        //$('#time').val(`${Math.round(avgTimeInMs)} ms`)\n        //$('#fps').val(`${faceapi.round(1000 / avgTimeInMs)}`)\n        this.setState({forwardTimes:forwardTimes})\n    }\n\n    resizeCanvasAndResults(dimensions, canvas, results) {\n        const { width, height } = dimensions instanceof HTMLVideoElement\n            ? faceapi.getMediaDimensions(dimensions)\n            : dimensions\n        canvas.width = width\n        canvas.height = height\n        \n        // resize detections (and landmarks) in case displayed image is smaller than\n        // original size\n        return faceapi.resizeResults(results, { width, height })\n    }\n    \n    drawDetections(dimensions, canvas, detections) {\n        //console.log(resizeCanvasAndResults)\n        const resizedDetections = resizeCanvasAndResults(dimensions, canvas, detections)\n        faceapi.drawDetection(canvas, resizedDetections)\n    }\n      \n    drawLandmarks(dimensions, canvas, results, withBoxes = true) {\n        const resizedResults = this.resizeCanvasAndResults(dimensions, canvas, results)\n        \n        if (withBoxes) {\n            faceapi.drawDetection(canvas, resizedResults.map(det => det.detection))\n        }\n        \n        const faceLandmarks = resizedResults.map(det => det.landmarks)\n        const drawLandmarksOptions = {\n            lineWidth: 2,\n            drawLines: true,\n            color: 'green'\n        }\n        faceapi.drawLandmarks(canvas, faceLandmarks, drawLandmarksOptions)\n    }\n\n    async onPlay(videoEl) {\n        if(!videoEl.currentTime || videoEl.paused || videoEl.ended)\n          return setTimeout(() => this.onPlay(videoEl))\n\n        let inputSize = 512\n        let scoreThreshold = 0.5\n        let withFaceLandmarks = false\n        let withBoxes = true\n        const options = new faceapi.TinyFaceDetectorOptions({ inputSize, scoreThreshold })\n        \n        const ts = Date.now()\n        const faceDetectionTask = faceapi.detectAllFaces(videoEl, options)\n        const results = withFaceLandmarks\n          ? await faceDetectionTask.withFaceLandmarks()\n          : await faceDetectionTask\n        this.updateTimeStats(Date.now() - ts)\n        const drawFunction = withFaceLandmarks\n          ? this.drawLandmarks\n          : this.drawDetections\n        drawFunction(videoEl, document.getElementById('overlay'), results, withBoxes)\n        setTimeout(() => this.onPlay(videoEl))\n    }\n\n    capture = async () => {\n        const imageSrc = this.webcam.getScreenshot();\n        this.setState({capturedImage:imageSrc})\n        let _this = this\n    \n        const input = document.getElementById('snapshot')\n        const detections = await faceapi.detectAllFaces(input)\n        const detectionsForSize = faceapi.resizeResults(detections, { width: input.width, height: input.height })\n        const canvas = document.getElementById('snapshot-canvas')\n        canvas.width = input.width\n        canvas.height = input.height\n        faceapi.drawDetection(canvas, detectionsForSize, { withScore: true })\n        //console.log(detections)\n\n        if(detections.length==0) \n            alert('没有捕获到面部!')\n        else {\n            let detection = detections[0]\n            let image = new Image()\n            image.src = imageSrc\n            image.onload = () =>{\n                let context = document.getElementById('cutted').getContext('2d')\n                let sourceX = detection.relativeBox.x*MEDIA_WIDTH\n                let sourceY = detection.relativeBox.y*MEDIA_HEIGHT\n                let sourceWidth = detection.relativeBox.width*MEDIA_WIDTH\n                let sourceHeight = detection.relativeBox.height*MEDIA_HEIGHT\n                //console.log(sourceX,sourceY,sourceWidth,sourceHeight)\n                context.drawImage(image,sourceX,sourceY,sourceWidth,sourceHeight,0,0,100,100)\n                let splited = context.getImageData(0,0,100,100)\n                //context.putImageData(splited,50,50)\n                console.log(splited)\n                //console.log(context.canvas.toDataURL())\n\n                axios({\n                    method:'post',\n                    url:'http://localhost:5000/face_img',\n                    crossDomain:true,\n                    data:{\n                        msg:'face snapshot',\n                        matrix:splited,\n                        width:100,\n                        height:100\n                    }\n                }).then(function (res) {\n                    console.log(res.data)\n                    _this.props.updateEcharts(res.data.data)\n                }).catch(function (error) {\n                    console.log(error);\n                });\n            }\n        }\n    };\n    \n\n    render() {\n        const { classes } = this.props;\n        const videoConstraints = {\n            width: 320,\n            height: 240,\n            facingMode: \"user\"\n        };\n        \n        return (\n            <div>\n            <Card className={classes.card}>\n            <div id=\"extraMount\"></div>\n            <CardContent >\n                <Typography className={classes.title} color=\"textSecondary\" gutterBottom>\n                Web Camera\n                </Typography>\n                <div>\n                    <canvas \n                        className={classes.overlay}\n                        id=\"overlay\">\n                    </canvas>\n                    <Webcam\n                        id=\"webcam\"\n                        className={classes.video}\n                        audio={false}\n                        width={MEDIA_WIDTH}\n                        height={MEDIA_HEIGHT}\n                        ref={this.setRef}\n                        screenshotFormat=\"image/jpeg\"\n                        videoConstraints={videoConstraints}\n                    />\n                </div>\n                <Button \n                    variant=\"contained\" \n                    color=\"primary\" \n                    className={classes.button}\n                    onClick={this.capture}\n                >Capture</Button>\n                <div>\n                    <canvas \n                    className={classes.overlay}\n                    id=\"snapshot-canvas\"\n                    />\n                    <img \n                    className={classes.video}\n                    id = \"snapshot\"\n                    src={this.state.capturedImage}\n                    alt = \"captured\"\n                    />\n                </div>\n            </CardContent>\n            </Card>\n            <canvas  id=\"cutted\"></canvas>\n            </div>\n        );\n    }\n}\n\nCameraSection.propTypes = {\n    classes: PropTypes.object.isRequired,\n};\n\nexport default withStyles(styles)(CameraSection);\n","import React, { Component } from 'react';\n\nimport CameraSection from './CameraSection'\nimport ChartsSection from './ChartsSection'\n\nclass Main extends Component {\n\n    state = {\n        echartsData:null\n    }\n\n    updateEcharts(data) {\n        this.setState({echartsData:data})\n    }\n\n    render() {\n        const echartsData = this.state.echartsData\n        return (\n            <div>\n                <CameraSection updateEcharts={this.updateEcharts.bind(this)}/>\n                {echartsData===null?null:<ChartsSection data={this.state.echartsData}/>}\n            </div>\n        );\n    }\n}\n\nexport default Main;\n","import React, { Component } from 'react';\nimport logo from './logo.svg';\nimport './App.css';\nimport { BrowserRouter, Route} from 'react-router-dom';\n\nimport Main from './Main'\nimport Demo from './Demo'\n\nclass App extends Component {\n  render() {\n    return (\n      <div style={{margin:'10px'}}>\n        <Main/>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","import React, { Component } from 'react';\n\nclass Demo extends Component {\n  render() {\n    return (\n        <div>\n            <h1>Demo</h1>\n        </div>\n    );\n  }\n}\n\nexport default Demo;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}